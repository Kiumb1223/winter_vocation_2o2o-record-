# 程序的控制结构

[toc]

## 分支结构

* 单分支结构    **根据判断条件结果而选择不同向前路径的运行方式** 

  ```python
  if <条件>:
  	<语句块>
  ```

  ```python
  guess = eval(input())
  if guess == 99:
  	print("猜对了")
  #判断条件可以直接使用真假来表示
  if True:
      print("条件正确")
  ```

* 二分支结果   **根据判断条件结果而选择不同向前路径的运行方式** 

  ```python
  if<条件>:
  	<语句块1>
  else:
  	<语句块2>
  ```

  ```python
  guess=eval(input("请输入数字："))
  if guess == 99:
  	print("猜对了")
  else:
  	print("猜错了")
  ```

  紧凑形式   **仅适用于表达简单逻辑的二分之结构的一种紧凑方式** 

  `<表达式1> if <条件> else <表达式2>`

  ```python
  guess = eval(input())
  print("猜{}了"。format("对" if guess ==99 else "错"))
  ```

* 多分支结构 

  ```python
  if<条件1>:
  	<语句块1>
  elif<条件2>:
  	<语句块2>
  .......
  else:
  	<语句块n>
  ```

  **注意多条件之间的包含关系** 

  **注意变量取值范围的覆盖** 

* 条件判断及组合

  | 操作符 | 数学符号 |   描述   |
  | :----: | :------: | :------: |
  |   <    |    <     |   小于   |
  |   <=   |  $\leq$  | 小于等于 |
  |   >=   |  $\geq$  | 大于等于 |
  |   >    |    >     |   大于   |
  |   ==   |    =     |   等于   |
  |   !=   |  $\neq$  |  不等于  |

* 条件组合   **用于条件组合的三个保留字** 

  | 操作符及使用 | 描述                     |
  | ------------ | ------------------------ |
  | x ==and== y  | 两个条件x和y的逻辑**与** |
  | x ==or== y   | 两个条件x和y的逻辑**或** |
  | ==not== x    | 条件x的逻辑**非**        |

  ```python
  guess = eval(input())
  if guess < 99 or guess > 99:
  	print("猜错了")
  else:
  	print("猜对了")
  ```

* 程序的异常处理 **异常处理的基本使用** 

  ```python
  try :
  	<语句块1>
  except <异常类型>:   #我们也可以指定异常出现的名称
  	<语句块2>
  ```

  ```python
  try :
      num=eval(input("请输入整数:"))
      print(num**2)
  except :   #1.标注异常类型后，仅响应该异常 2.异常类型名字等同于变量
      print("输入的不是整数！")
  ​```
  在第四行我们也可以指定异常类型的名称如    except NameError :
  在这段程序中假设输入”abc" eval()函数去掉外围的双引号后 是abc
  系统认为abc为变量名字，而我们未定义过 所以产生了NameError的异常类型错误
  还有一点指的注意的是   所有异常类型的名称是Python语言中预定义的
  ​```
  ```

  **异常处理的高级使用** 

  ```python
  try :
      <语句块1>
  except :
      <语句块2>
  else :
      <语句块3>
  finally :
      <语句块4>
  ```

  * ==finally==对应的语句块4一定执行

  * ==else==对应的语句块3在不发生异常时执行

  * 我们可以理解为 

    先去执行语句块1的一部分代码

    如果不发生异常 我们去奖励性的让他执行语句块3

    如果发生了异常 让它执行语句块2

    无论发不发生异常 最后都要执行语句块4

   * 通过这种方式，Python可以处理更多的异常处理相关逻辑

* 实例  身体质量指数BMI

  ```python 
  #CalBMIv3.py
  height,weight = eval(input("请输入身高（米）和体重（公斤）[逗号隔开]："))
  bmi = weight / pow(height,2)
  print("BMI数值为：{:.2f}".format(bmi))
  who,nat = "",""
  if bmi < 18.5:
      who,nat ="偏瘦","偏瘦"
  elif 18.5<=bmi<24:
      who,nat="正常","正常"
  elif 24 <= bmi < 25:
      who,nat="正常","偏胖"
  elif 25 <=bmi <28:
      who,nat ="偏胖","偏胖"
  elif 28<= bmi <30:
      who,nat ="偏胖","肥胖"
  else:
      who,nat ="肥胖","肥胖"
  print("bmi指标为国际‘{0}’，国内‘{1}’".format(who,nat))
  ```

  * 多分枝条件之间的覆盖是重要问题
  * 程序可运行，但不正确，要注意多分支
  * 分支结构是程序的重要框架，读程序先看分支

## 循环结构

遍历循环

无限循环

循环控制保留字

循环的高级用法

* 遍历循环

  ==for== <循环变量> ==in== <遍历结构>:

  ​	<语句块>

  * 由保留字==for== 和==in== 组成，完整遍历所有元素后结束

  * 每次循环，所获得元素放入循环变量，并执行一次语句块

  * 遍历循环有许多的应用。下面介绍常用的搭配方式:

    * ==计数循环（N次）==

      ==for==  i ==in==  range(N):

      ​	<语句块>

      * 遍历由range()函数产生的数字序列，产生循环

      * **至于使不使用中间的循环变量i，由程序的逻辑来决定**

      * 拓展range()的使用方式

        ==for==  i ==in==  range(M,N,K):      #请不要弄混字符串的方法 ---切片的高级用法

        ​	<语句块>  						#[M,N]为区间   k为步长、

    * ==字符串遍历循环== 

      ==for==  c ==in==  s :

      ​	<语句块>

      * s是字符串，遍历字符串每个字符，产生循环

        ```python
        >>> for c in "python123":
        	print(c,end=',')
        
        p,y,t,h,o,n,1,2,3,
        ```

    * ==列表遍历循环==

      ==for==  item ==in==  ls :

      ​	<语句块>

      * ls是一个列表，遍历其每个元素，产生循环

        ```python
        >>> for item in ['123','py','456']:
        	print(item,end=',')
        
        123,py,456,
        ```

    * ==文件遍历循环== 

      ==for==  line  ==in==   fi :

      ​	<语句块>

      * fi是一个文件标识符[^1]，遍历其每行，产生循环
      * line遍历该文件的每一行

[^1]:可以对一个外部的文件，通过Python的函数将文件打开。如果这个文件是以字符文件形式打开，那它就会表示一个文件的标识的名字，相当于我用一个变量来标识系统中的一个文件这个变量就叫文件标识符

* 无限循环   ==由条件控制的循环运行方式== 

  ==while==  <条件>:

  ​	<语句块>

  * 反复执行语句块，直到条件不满足时结束

    ```python 
    >>>a=3
    >>> while a>0:
    		a-=1      #a+=1
    		print(a)退出当前
    #无限循环，循环执行又永不退出  我们可以选择Ctrl+C组合键来退出循环
    ```

* 循环控制保留字     ==break continue==      和C语言一模一样

  * break跳出并结束当前整个循环，执行循环后的语句
  * continue结束当次循环，继续执行后续次数循环
  * break和continue可以与for和while循环搭配使用

* 循环的高级用法   ==循环与else== 

  1. ==for== <循环变量> ==in== <遍历结构>:

     ​	<语句块>

     ==else== :

     ​	<语句块>

  2. ==while==  <条件>:

     ​	<语句块>

     ==else== :

     ​	<语句块>

  * 当循环没有被break语句退出时，执行else语句块

    不是continue:angry:

  * else语句块作为“正常”完成循坏的奖励

  * 这里else的用法与异常处理中的else用法相似

## random库

==random库是使用随机数的Python标准库== 

* 伪随机数：采用梅森旋转算法生成的（伪）随机序列中的元素

* random库主要用于生成随机数——计算机不能产生随机数

* random库的使用：==import== random  

* random库中常用的函数有==8== 个

  * 基本随机数函数：seed (),random()

  * 扩展随机数函数:randint(),getrandbits(),uniform()

    ​							randrange(),choice(),shuffle()
  
  1. 基本随机函数：Python种的随机数使用随机数种子来产生
  
     ```flow
     st=>operation: 随机数种子
     e=>operation: 梅森旋转算法
     s=>operation: 随机序列
     st(right)->e(right)->s
     
     ```
  
     只要种子相同，产生的随机序列，无论是每一个数，还是数之间的关系所以**随机数种子确定了随机序列的产生** 
  
     | 函数         | 描述                                                         |
     | ------------ | ------------------------------------------------------------ |
     | seed(a=None) | 初始化给定的随机数种子，默认为当前系统时间<br>>>>random.seed(10)# 产生种子10对应的序列 |
     | random()     | 生成一个[0.0,1.0)之间的随即小数<br>>>>random.random()<br>0.5714025946899135 |
  
     ```python
     >>> import random
     >>> random.seed(10)    #种子我们只需给一次，那么随机数就会随着每次调用产生不同随机数
     >>> random.random()
     0.5714025946899135
     >>> random.random()
     0.4288890546751146
     >>> 
     ```
  
     ps：假如我们不给种子时，那么种子就是第一次调用random.random()的系统时间
  
     ​        我们为什么要给定种子呢？ 
  
     ​		就是因为如果你编程中给出了随机种子，那么下一次程序运行，给定的种子相同，那么产生的随机数也是相同的，**对于使用随机数的程序，我们可以复现或者再现你程序运行的过程**。如果不使用随机数种子，那么它使用的是当前系统时间，**而那个时间是精确到微秒的**，而这个时间是我们很难再现的，所以后面产生的程序运行的结果就是完全随机。这就得需要看**程序需求**
  
     ```python 
     >>> import random
     >>> random.seed(10)
     >>> random.random()
     0.5714025946899135
     >>> random.seed(10)
     >>> random.random()
     0.5714025946899135
     ```
  
     从这我们可以看出**我们只要调用了`random.seed()`设置种子的函数 ，后续调用`random`函数的顺序，只要相同，那么产生的随机数也是相同的** 
  
  2. 扩展随机数函数
  
     | 函数               | 描述                                                         |
     | ------------------ | ------------------------------------------------------------ |
     | randint(a,b)       | 生成一个[a,b]之间的整数<BR>>>>random.randint(10,100)<br>64   |
     | randrange(m,n[,k]) | 生成一个[m,n)之间以k为步长的随机整数<br>>>>random.randrange(10,100,10)<bR>80 |
     | getrandbits(k)     | 生成一个k比特长的随机整数                                    |
     | uniform(a,b)       | 生成一个[a,b]之间的随即小数<br>生成的小数也是在小数点后16位为精度的 |
     | choice(seq)        | 从序列seq中随机选择一个元素<br>>>>random.choice([1,2,3,4,5,6,7,8,9])<br>8 |
     | shuffle(seq)       | 将序列seq中元素随机排列，返回打乱后的序列<br>>>>s=[1,2,3,4,5,6,7,8,9];random.shuffle(s);print(s)[^2] |

[^2]:在Python中如果非常有必要将几行代码写在同一行中，那么则需在代码中添加**分号**

            3. 随机数函数的使用    需要掌握的能力
               * 能够利用随机数种子产生“确定”伪随机数
               * 能够产生随机整数
               * 能够对序列类型进行随机操作

## 实例  圆周率的计算

法一:$\pi=\Sigma_{k=0}^{\infty}[\frac{1}{16^{k}}*(\frac{4}{8k+1}-\frac{2}{8k+4}-\frac{1}{8k+5}-\frac{1}{8k+6})]$

```python
#Calpiv1.py
pi=0
N=100
for k in range (N):
    pi +=1/pow(16,k)*(\
        4/(8*k+1)-2/(8*k+4)-\
         1/(8*k+5)-1/(8*k+6))
print("圆周率为：{}".format(pi))
```

这里面有个小技巧：如果当你写一段代码

，这段代码特别长，在一行中无法表达，或者表达在一行中，他的编写的可读性很差，我们可以在**这段代码中增加\使代码进行换行**

法二：蒙特卡罗

```python 
#Calpiv2.py
from random import random 
from time import perf_counter
DARTS = 1000*1000
hits =0.0
start =perf_counter()
for i in range (DARTS+1):
    x,y=random(),random()
    dist=pow(x**2+y**2,0.5)
    if dist <= 1.0:
        hits +=1
pi =4 *(hits/DARTS)
print("圆周率值是：{}".format(pi))
print("运行的时间是：{}".format(perf_counter()-start))
```


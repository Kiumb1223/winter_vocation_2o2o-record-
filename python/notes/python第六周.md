[toc]

# 组合数据类型

* 集合类型及操作
* 序列类型及操作
* 字典类型及操作
## 集合类型及操作

* 集合类型的定义   ==集合是多个元素的无序组合== 

  * 集合类型与数学中的集合概念一致

  * 集合元素之间无序，每个元素唯一，不存在相同元素

  * 集合元素不可更改，不能是可变数据类型   

    ==为什么？==    第二点定义

  * 集合用大括号{}表示，元素间用逗号分隔

  * 建立集合类型用{}或set()

  * 建立空集合类型，必须使用set()

    ```python 
    >>>{"python",123,("python",123)}  #使用{}建立集合
    {123, ('python', 123), 'python'}
    >>> set("pypy123")     #使用set()建立集合
    {'p', '1', '3', '2', 'y'}
    >>> {"python",123,"python",123}
    {123, 'python'}
    ```

  * ==重点== 

    * 集合用大括号{}表示，元素间用逗号分隔
    * 集合中每个元素唯一，不存在相同元素
    * 集合元素之间无序
  
* 集合操作符

  * 集合间操作

    <table>
      <tr>
            <td>
                <center>
            <img src=‪"F:\Typora\edit_pic\并集.png"> S|T 并
                </center>
            </td>
            <td><center>
            <img src="F:\Typora\edit_pic\交集.png">  S&T 交
                </center>
            </td>
        </tr>
        <tr>
           <td><center>
               <img src=‪"F:\Typora\edit_pic\补集.png">  S^T 补
               </center>
            </td>
            <td><center>
                <img src=‪"F:\Typora\edit_pic\差集.png"> S-T 差
                </center>
            </td>
        </tr>
    </table>
    
  * 6个操作符
  
    | 操作符及应用 | 描述                                               |
    | ------------ | -------------------------------------------------- |
    | S\|T         | 返回一个新集合，包括在集合S和T中的所有元素（并集） |
    | S-T          | 返回一个新集合，包括在集合S但不在T中的元素（差集） |
    | S&T          | 返回一个新集合，包括同时在集合S和T中的元素（交集） |
    | S^T          | 返回一个新集合，包括集合S和T中的非相同元素（补集） |
    | S <= T或S<T  | 返回True/False，判断S和T的子集关系                 |
    | S>=T或S>T    | 返回True/False，判断S和T的包含关系                 |
  
    ==4个增强操作符== 
  
    | 操作符及应用 | 描述                                  |
    | ------------ | ------------------------------------- |
    | S\|=T        | 更新集合S，包括在集合S和T中的所有元素 |
    | S-=T         | 更新集合S，包括在集合S但不在T中的元素 |
    | S&=T         | 更新集合S，包括同时在集合S和T中的元素 |
    | S^=T         | 更新集合S，包括集合S和T中的非相同元素 |
  
* 集合处理方法

  | 操作函数或方法 | 描述                                                         |
  | -------------- | ------------------------------------------------------------ |
  | S.add(x)       | 如果x不在集合S中，将x增加到S中                               |
  | S.discard(x)   | 移除S中的元素x，如果x不在集合S中，则报错                     |
  | S.remove(x)    | 移除S中的元素x，如果x不在集合S中，产生KeyError异常           |
  | S.clear()      | 移除S中的所有元素                                            |
  | S.pop()        | 随机返回S的一个元素，同时在集合S中删去这个元素<br>若S为空 产生KeyError异常 |
  | S.copy()       | 返回集合S的一个副本                                          |
  | len(S)         | 返回集合S的元素个数                                          |
  | X in S         | 判断S中的元素X，X在集合S中，返回True,否则返回False           |
  | X  not in S    | 判断S中的元素X，X不在集合S中，返回True，反之， 返回False     |
  | set(X)         | 将其他类型变量X转化为集合类型                                |

  ```python
  >>> A ={"p","y",123}
  >>> for item in A:
  	print(item,end="")
  py123
  >>> A
  {'p', 'y', 123}
  #由于集合元素是没有顺序的，所以使用for in的形式去返回获得元素也是不确定的
  #这里的不确定是用for in 的方式获取变量的时候，它可能与你定义的顺序不同
  #但是一旦一个集合类型定义生成之后，其内部其实是有一个顺序的，只不过这个顺序对于程序员来讲，没法利用，他是程序内部去保存集合的时候，所运用的一种顺序 
  ```

  ```python 
  try:
      while True:
          print(A.POP(),end="")
      except:
          pass
  ```
  
* 集合类型应用场景
  
* 包含关系
  
  ```python 
    >>>"P" in {"P","y",123}
    True
    >>> {"P","Y"}>={"P","Y",123}
    False
  ```
  
  * 数据去重：==集合类型所有元素无重复== 
  
    ```python
    >>>ls =["p","p","y","y",123]
    >>>s=set(ls)  #数据去重  利用了集合无重复元素的特点
    >>>ls=list(s) #将集合转换成列表
    
    ```
  

## 序列类型及操作

* 序列类型定义   

  ​    ==序列是具有先后关系的一组元素==  

  ​													  ---序列元素可以相同

  * 序列是一维元素向量，元素类型可以不同
  * 类似数学元素的序列：$s_{0},s_{1},\dots,s_{n-1}$
  * 元素间由序号引导，通过下标访问序列的特定元素 

  ​     ==序列是一个基本类型== 

  ```mermaid
  graph TD
  A[序列类型] -->B[字符串类型]
  A --> c[元组类型]
  A --> D[列表类型]
  ```

  ​         ==序号类型== 

  * 正向递增序号

  * 反向递减序号

  * <table>
        <tr>
            <td colspan ="5">反向递减序号</td>
        </tr>
        <tr>
        <td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td> 
        </tr>
        <tr>
            <td>"BIT"</td><td>3.1415</td><td>1024</td><td>(2,3)</td>
            <td>["中国",9]</td>
        </tr>
        <tr>
            <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
        </tr>
        <tr>
        <td colspan ="5">正向递增序号</td>
        </tr>
    </table>

* 序列处理函数及方法

  * ==6个操作符== 

    | 操作符及应用     | 描述                                                     |
    | ---------------- | -------------------------------------------------------- |
    | X in S           | 判断S中的元素X，X在序列S中，返回True,否则返回False       |
    | X  not in S      | 判断S中的元素X，X不在序列S中，返回True，反之， 返回False |
    | S + T            | 连接两个序列S和T                                         |
    | S*n或n\*S        | 将序列复制n次                                            |
    | S[i]             | 索引，返回S中的第i个元素，i是序列的序号                  |
    | S[i:j]或S[i:j:k] | 切片，返回序列S中第i到j以k为步长元素子序列               |

    ```python
    >>> ls =["python",123,".io"]
    >>> ls[::-1]
    ['.io', 123, 'python']
    ```

  * ==5个函数和方法== 

    | 函数和方法                     | 描述                                           |
    | ------------------------------ | ---------------------------------------------- |
    | len(s)                         | 返回序列S的长度                                |
    | min(S)                         | 返回序列S的最小元素，S中的元素需要可比较[^1]   |
    | max(s)                         | 返回序列S的最大元素，S中的元素需要可比较[^1]   |
    | s.index(x)或<br>s.index(x,i,j) | 返回序列S从i开始到j位置中第一次出现元素X的位置 |
    | s.count(x)                     | 返回序列S中出现X的总次数                       |

    [^1]:如果不同类型的数据，则会报错

  ### 元组类型 

  1. **定义** 

  ==元组是序列类型的一种拓展== 

  * 元组是一种序列类型，一旦创建就不能被修改

  * 使用小括号`()`或`tuple()`创建，元素间用逗号,分隔

  * 可以使用或不适用小括号

    ```python
    def func():
        return 1,2
    # 这里python返回一个元组类型
    ```

    ```python 
    >>> creature="cat","dog","tiger","human"
    >>> creature
    ('cat', 'dog', 'tiger', 'human')
    >>> color=(0x123456,"blue",creature)
    >>> color
    (1193046, 'blue', ('cat', 'dog', 'tiger', 'human'))
    ```
  2. **操作** 

     ==元组继承序列类型的全部通用操作== 

     * 元组继承了序列类型的全部通用操作

     * 元组因为创建后不能修改，因此没有特殊操作

     * 使用或不使用括号

       ```python
       >>> creature[1:2]
       ('dog',)
       >>> color[-1][2]  #color[-1]是生成了一个新的元组类型
       'tiger'
       ```

### 列表类型

1. 定义

   ==列表是序列类型的一种拓展，十分常用== 

   * 列表是一种序列类型，创建后可以随意被修改

   * 使用方括号[]或`list()`创建，元素间用逗号`，`分隔

   * 列表中各元素类型可以不同，无长度限制

     ```python 
     >>> ls=['cat', 'dog', 'tiger', 'human']
     >>> lt=ls    #赋值仅传递引用
     >>> lt       #这里是ls,lt同时指向该列表
     ['cat', 'dog', 'tiger', 'human']
     #  看这！！！！！
     >>> ls *=2
     >>> ls
     ['cat', 'dog', 'tiger', 'human', 'cat', 'dog', 'tiger', 'human']
     >>> lt
     ['cat', 'dog', 'tiger', 'human', 'cat', 'dog', 'tiger', 'human']
     ```

2. 列表类型操作函数和方法

   | 函数和方法    | 描述                                |
   | ------------- | ----------------------------------- |
   | ls[i]=X       | 替换列表ls第i个元素为X              |
   | ls[i:j:k]=lt  | 用列表lt替换ls切片所对应元素子列表  |
   | del ls[i]     | 删除列表ls中第i元素                 |
   | ls += lt      | 更新列表ls，将lt元素增加到列表ls中  |
   | ls *=n        | 更新列表ls，其元素重复n次           |
   | del ls[i:j:k] | 删除列表ls中第i到第j以k为步长的元素 |

   | 函数或方法     | 描述                                |
   | -------------- | ----------------------------------- |
   | ls.append(X)   | 在列表ls最后增叫一个元素X           |
   | ls.clear()     | 删除列表ls中的所有元素              |
   | ls.copy()      | 生成一个新列表，赋值ls中所有元素    |
   | ls.insert(i,x) | 在列表ls的第i位置增加元素x          |
   | ls.pop(i)      | 将列表ls中第i位置元素去除并删除元素 |
   | ls.remove(x)   | 将列表ls中出现的第一个元素x删除     |
   | ls.reverse()   | 将ls中的元素反转                    |

### 序列类型应用场景

- 元组用于元素不改变的应用场景，更多用于固定搭配场景

  函数返回值return 

- 列表更加灵活，它是最常用的序列类型

  用一个数据类型处理一组数据，并且处理功能比较多样

- 最主要的作用：表述一组有序数据，进而操作他们

  

==元素遍历== 

```python 
for item in ls :  #列表
    <语句块>
for item in tp:    #元组类型
    <语句块>
```

==数据保护== 

* 如果不希望数据被程序所改变，转换成元组类型

```python 
>>> ls =["cat","dog","tiger",1024]
>>> lt =tuple(ls)
>>> lt
('cat','dog','tiger',1024)
```



## 基本统计值

* 问题分析
  * 总个数：len()
  * 求和：for  in 
  * 平均值：求和/总个数
  * 方差：个数据与平均数差的平方的和的平均数
  * 中位数：排序，然后...奇数找中间1个，偶数找中间2个取平均

* 代码编写

  ```python 
  #CalStatisticsV1.py
  def getNum():    #获取用户不定长度的输入
      nums=[]
      iNumStr=input("请输入数字（回车退出）：")
      while iNumStr!="":
          nums.append(eval(iNumStr))
          iNumStr = input("请输入数字（回车退出）：")
   return nums
  
  def mean(numbers):   #计算平均值
      s=0.0
      for num in numbers:
          s+=num
  return s/len(numbers)
  
  def dev(numbers,mean):    #计算方差
      sdev=0.0
      for num in numbers:
          sdev+=(num-mean)**2
  return pow(sdev/(len(numbers)-1),0.5)
  def median(numbers):
      sorted(numbers)
      size =len(numbers)
      if size % 2== 0:
          med =(numbers[size//2-1]+numbers[size//2])/2
      else :
          med =numbers[size//2]
  return med
  n=getNum()
  m=mean(n)
  print("平均值：{}，方差：{：.2}，中位数：{}。".format(m,dev(n,m),median(n)))
  ```

## 字典类型

1. 定义   

   ==理解”映射“== 

   * 映射是一种键（索引）和值（数据）的对应

     映射更多是表达了某一个属性跟它对应的值

     映射本身是一种索引或一种属性与数据之间的对应关系

     * 序列类型由0$\dots$N整数作为数据的默认索引

     * 映射类型则由用户为数据定义索引

     **字典类型是数据组织与表达的一种新的形态** 

   ==字典类型是”映射“的体现== 

   * 键值对：键是数据索引的拓展

   * 字典是键值对的集合，键值对之间无序

   * 采用大括号{}和`dict()`创建，键值对用冒号：表示

     `{<键1>:<值1>,<键2>:<值2>,...<键n>:<值n>}`

   ==在字典变量中，通过键获得值== 

   `<字典变量>={<键1>:<值1>,<键2>:<值2>,...<键n>:<值n>}`

   `<值>=<字典变量>[<键>]` 	`<字典变量>[<键>]=<值>    #增加/修改键值对元素`

   **[]用来向字典变量中索引或增加元素** 

   ```python 
   >>> de ={}
   >>>de 
   {}
   >>>type(de)    #type(x)  返回变量x的类型
   <class 'dict'>
   ```

   * 小的知识点：

     集合类型也是由”{}“来表示的，集合里的元素就是一个基本元素，它不是一个键值对。

     而字典类型的每一个元素是一个键值对

     我们在集合类型中要求大家，如果生成一个空的集合类型，不能使用”{}“方式

     **这是因为”{}“是默认生成字典类型的**  

     因为字典类型在计算机编程中会非常常用，所以我们将”{}“空的形式，保留给空字典类型来使用

3. 字典处理函数及方法

    

   | 函数或方法 | 描述                                                |
   | ---------- | --------------------------------------------------- |
   | del d[k]   | 删除字典d中键k对应的数据值                          |
   | k in d     | 判断**键k**是否在字典d中，如果在返回True，否则False |
   | d.keys()   | 返回字典d中所有的键信息                             |
   | d.values() | 返回字典d中所有的值信息                             |
   | d.items()  | 返回字典d中的所有键值对信息                         |

   ```python 
   >>> d={"中国":"北京","美国":"华盛顿","法国":"巴黎"}
   >>> "中国" in d
   True 
   >>> d.keys()     # 返回一种字典的key类型而不是列表类型   可以用for in 做遍历
   dict_keys(['中国', '美国', '法国'])
   >>> d.values()	#返回的是一种字典的values类型，可以用for in 做遍历
   dict_values(['北京', '华盛顿', '巴黎'])
   ```

   | 函数或方法          | 描述                                          |
   | ------------------- | --------------------------------------------- |
   | d.get(k,<default\>) | 键k存在，则返回相应值，不在则返回<default\>值 |
   | d.pop(k,<default\>) | 键k存在，则取出相应值，不在则返回<default\>值 |
   | d.popitem()         | 随机从字典d中取出一个键值对，以元组形式返回   |
   | d.clear()           | 删除所有键值对                                |
   | len(d)              | 返回字典d中的元素个数                         |

4. 字典类型应用场景

   ==映射的表达== 

   * 映射无处不在，键值对无处不在
   * 例如：统计数据出现的次数，数据是键，次数是值
   * 最主要作用：表达键值对数据，进而操作他们

   ==元素遍历== 

```python 
for k in d: 	#由键来逐一索引字典中的对应的值
    <语句块>
```

## jieba库

* 概述

  ==jieba库是优秀的中文分词第三方库== 

  * 中文文本需要通过分词获得单个的词语
  * jieba是优秀的中文分词第三方库
  * jieba库提供三种分词模式，最简单只需要掌握一个函数

* jieba分词的原理  

  ==jieba分词依靠中文词库== 

  * 利用一个中文词库，确定汉字之间的关联概率
  * 汉字间概率大的组成词组，形成分词结果
  * 除了分词，用户还可以添加自定义的词组

* jieba分词的三种模式

  ==精确模式、全模式、搜索引擎模式== 

  * 精确模式：把文本精确的切分开，不存在冗余单词
  * 全模式：把文本中所有可能的词语都扫描出来，有冗余
  * 搜索引擎模式：在精确模式基础上，对场次再次切分

* jieba库常用函数

  | 函数                       | 描述                                                         |
  | -------------------------- | ------------------------------------------------------------ |
  | jieba.lcut(s)              | 精确模式，返回一个列表类型的分词结果<br>>>>jieba.lcut("中国是一个伟大的国家")<br>['中国','是','一个','伟大','的','国家'] |
  | jieba.lcut(s,cut_all=True) | 全模式，返回一个列表类型的分词结果，存在冗余<br>>>>jieba.lcut("中国是一个伟大的国家",cut_all=True)<br>['中国','国是','一个','伟大','的','国家'] |
  | jieba.lcut_for_search(s)   | 搜索引擎模式，返回一个列表类型的分词结果，存在冗余<br>>>>jieba.lcut_for_search("中华人民共和国是伟大的")<br>['中华','华人','人民','共和','共和国','中华人民共和国','是','伟大','的'] |

## 文本词频统计

* 需求：一篇文章，出现了哪些词？哪些词出现的最多？该怎么做呢？
* 算了算了 夜深了累了 见课件吧 晚安:crescent_moon::kissing_heart:

